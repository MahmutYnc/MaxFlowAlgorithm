//Graf.class
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maxflowgui;

import com.mxgraph.layout.mxCircleLayout;
import com.mxgraph.layout.mxIGraphLayout;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.swing.util.mxSwingConstants;

import java.awt.Color;
import java.util.Arrays;
import javax.swing.JButton;

import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import org.jgrapht.ext.JGraphXAdapter;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleDirectedWeightedGraph;

/**
 * 
 * 
 *
 * @author siebe
 */
public class Graf extends javax.swing.JFrame {

    /**
     * Creates new form Graf
     */
    private int nodeCount;
    private String[] nodeNames;
    private String source, sink;
    private static int[][] matrix;
    public String information;
    
    public int maxResult = 0;
    public String minResult = "";

        //My attributes
        boolean[] isVisited;
        final static int startX = 40, startY = 250, addX = 100, addY = 100, srcY = 300;
        final static int WIDTH = 40, HEIGHT = 30;

    JPanel pane;
    JButton maxFlowBtn, mincutBtn;
    JTextField maxFlowRes;
    JTextArea minCutEdges;
    JTextArea maxPath;
    MaxFlow m = new MaxFlow(); 
    
    public Graf(int nodeCount, String[] nodeNames,int[][] matrix, String information) {
        this.nodeCount = nodeCount;
        this.nodeNames = nodeNames;
        this.information = information;
        this.matrix = matrix;
        
        setTitle("Max Flow Algorithm");
        initComponents();
        setVisible(true);
 
        
        createNodes2(matrix, nodeNames);
        this.add(pane);
        
    }
    private JButton buttons[];
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 904, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>                        

    /**
     * @param args the command line arguments
     */
    static int[][] graph = matrix;
    
    public static class MyEdge extends DefaultWeightedEdge {
        @Override
        public String toString() {
            return String.valueOf(getWeight());           
        }
     
    }
    public void createNodes2 (int[][] g, String[] vNames){
        
            //Create graph model
            SimpleDirectedWeightedGraph<String, MyEdge>  graph = 
            new SimpleDirectedWeightedGraph<>
            (MyEdge.class); 
            
            //count edges of the graph
            int edgeCount = 0;
            for (int i = 0; i < g.length; i++) {
                for (int j = 0; j < g[i].length; j++) {
                    if(g[i][j] != 0){
                        edgeCount++;
                    }
                }
            }
            //Create edge array 
            MyEdge[] edge = new MyEdge[edgeCount];
            
            for (int i = 0; i < g.length; i++) {
                String str = "Musluk" + (char)(65 + i);
                graph.addVertex(str);
            }
    
            
             
             int k = 0;
             for (int i = 0; i < g.length; i++) {
                for (int j = 0; j < g[i].length; j++) {
                    if(g[i][j] != 0){
                        
                        String from = "Musluk" + (char)(65 + i);
                        String to = "Musluk" + (char)(65 + j);
                        
                        edge[k] = graph.addEdge(from, to);
                        graph.setEdgeWeight(edge[k], g[i][j] );
                        k++;
                    }
                }
            }
            

        System.out.println("Shortest path from vertex1 to vertex5:");
           

        
        mxSwingConstants.EDGE_SELECTION_COLOR = Color.GREEN;
        mxSwingConstants.VERTEX_SELECTION_COLOR = Color.BLUE;
        

        JGraphXAdapter<String, MyEdge> graphAdapter = 
                new JGraphXAdapter<>(graph);

        mxIGraphLayout layout = new mxCircleLayout(graphAdapter);
        
        layout.execute(graphAdapter.getDefaultParent());
                
        
        System.out.println(graphAdapter.isEdgeLabelsMovable());
                        
        
        pane = new JPanel();
        pane.setLayout(null);
        pane.setBackground(new java.awt.Color(230, 230, 250));
        pane.setSize(new java.awt.Dimension(904, 640));
        
        
        mxGraphComponent mxi = new mxGraphComponent(graphAdapter);
        mxi.setPreferredSize(new java.awt.Dimension(600, 300));
        mxi.setBounds(100, 100, 804, 300);
        mxi.setLocation(40, 100);
        pane.add(mxi);
        
        
        //MaxFlow Button and algorithm
        maxFlowBtn = new JButton("Max-Flow");
        maxFlowBtn.setBounds(100, 500, WIDTH+40, HEIGHT);
        //set on action func here
        maxFlowBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                maxFlowBtnMouseClicked(evt);
            }
        });
        pane.add(maxFlowBtn);
        
        //Result of the maxFlow algorithm to display
        maxFlowRes = new JTextField();
        maxFlowRes.setBounds(200, 500, WIDTH+40, HEIGHT);
        maxFlowRes.setBackground(new java.awt.Color(230, 230, 250));
        maxFlowRes.setEditable(false);
        pane.add(maxFlowRes);
        
        //path of the maxFlow algorithm to display
        maxPath = new JTextArea();
        //maxPath.setBounds(300, 500, WIDTH*7 + 4, HEIGHT*4);
        maxPath.setBackground(new java.awt.Color(230, 230, 250));
        maxPath.setEditable(false);
        JScrollPane scroll = new JScrollPane(maxPath);
        scroll.setBounds(300, 500, WIDTH*7 + 4, HEIGHT*4);    
        pane.add(scroll);
        
        
        //Min-Cut Button and algorithm
        mincutBtn = new JButton("Min-Cut");
        mincutBtn.setBounds(604, 500, WIDTH+40, HEIGHT);
        //set on action func here
        mincutBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                mincutBtnMouseClicked(evt);
            }
        });
        pane.add(mincutBtn);
        
        //Result of the maxFlow algorithm to display
        minCutEdges = new JTextArea();
        minCutEdges.setBounds(704, 500, WIDTH*4, HEIGHT*3);
        minCutEdges.setBackground(new java.awt.Color(230, 230, 250));
        minCutEdges.setEditable(false);
        pane.add(minCutEdges);
        
    }
    
    private void maxFlowBtnMouseClicked(java.awt.event.MouseEvent evt) {

        System.out.println(Arrays.deepToString(matrix).replace("], ", "]\n").replace("[[", "[").replace("]]", "]"));
        
        maxResult = m.fordFulkerson(matrix, 0, matrix.length-1, nodeCount);
	System.out.println("The maximum possible flow is " + maxResult); 
        maxFlowRes.setText("-->"+maxResult);
        maxPath.setText(m.getString());
    }
    private void mincutBtnMouseClicked(java.awt.event.MouseEvent evt) {                                      
        
   	System.out.println(Arrays.deepToString(matrix).replace("], ", "]\n").replace("[[", "[").replace("]]", "]"));
       
        MinCut miny = new MinCut();
	minResult = miny.minCut(matrix, 0, matrix.length-1); 
        System.out.println("Edges between these Vertexes should be cut for Min - Cut algorithm: \n" + minResult); 
        minCutEdges.setText(minResult);
    }  
    /*
    //My own graph-builder
    public void createNodes (int[][] graph, String[] str) {
        //remove later
        buttons = new JButton[graph.length];
        isVisited = new boolean[graph.length];
        
        int currentX = 40, currentY = 250;
        
        System.out.println("graph length : "+ graph.length);
        
        //source Node 
        JButton btn = new JButton( 0 + ".");
        btn.setEnabled(false);
        btn.setBounds(startX, srcY, WIDTH, HEIGHT);
        buttons[0] = btn;
        jPanel1.add(btn);
        isVisited[0] = true;
        
        //nodes between source and sink       
        for (int i = 0; i < graph.length; i++) {            
            for (int j = 0; j < graph[i].length -1; j++) {
                
                if(!isVisited[j] && graph[i][j] != 0 && (j%2 != 0)){
                    btn = new JButton( j + ".");
                    btn.setEnabled(false);
                    btn.setBounds(currentX + addX, currentY, WIDTH, HEIGHT);
                    buttons[i] = btn;
                    jPanel1.add(btn);
                    isVisited[j] = true;
                    currentY += addY;
                    
                    //problemmy part is here 
                    btn = new JButton( j+1 + ".");
                    btn.setEnabled(false);
                    btn.setBounds(currentX + addX, currentY, WIDTH, HEIGHT);
                    buttons[i+1] = btn;
                    jPanel1.add(btn);
                    isVisited[j+1] = true;
                    currentY += addY;
                }                
                
            }
            currentY = startY;
            currentX += addX;
            
        }
        //SiNK NODE
        btn = new JButton( graph.length-1 + ".");
        btn.setEnabled(false);
        btn.setBounds((graph.length / 2 ) * 100 + 40 , srcY, WIDTH, HEIGHT);
        buttons[graph.length - 1] = btn;
        jPanel1.add(btn);
        isVisited[graph.length-1] = true;
    }*/

    // Variables declaration - do not modify                     
    // End of variables declaration                   
}


//Requirements.class
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maxflowgui;

import java.awt.Color;
import java.util.Arrays;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JOptionPane;

/**
 *
 * @author siebe
 */
public class Requirements extends javax.swing.JFrame {

    /**
     * Creates new form Requirements
     */
    public Requirements() {
        initComponents();
    }
    String info = "";
    StringBuilder infoBuilder = new StringBuilder();
    int nodeC = 0;
    int[][] graph; 
    String[] items;
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        nodeCount = new javax.swing.JTextPane();
        jButton1 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        NodeSelectComboBox = new javax.swing.JComboBox<>();
        jCheckBox1 = new javax.swing.JCheckBox();
        jCheckBox2 = new javax.swing.JCheckBox();
        selected1 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        selected2 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();
        selected3 = new javax.swing.JLabel();
        jTextField3 = new javax.swing.JTextField();
        selected4 = new javax.swing.JLabel();
        jTextField4 = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        nodeConnectionBtn = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Max Flow Algorithm");
        setMinimumSize(new java.awt.Dimension(904, 640));
        setPreferredSize(new java.awt.Dimension(720, 660));
        setResizable(false);

        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.LINE_AXIS));

        jPanel2.setBackground(new java.awt.Color(230, 230, 250));
        jPanel2.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jPanel2.setMinimumSize(new java.awt.Dimension(240, 138));
        jPanel2.setPreferredSize(new java.awt.Dimension(240, 138));
        jPanel2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPanel2MouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jPanel2MouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jPanel2MouseExited(evt);
            }
        });
        java.awt.GridBagLayout jPanel2Layout = new java.awt.GridBagLayout();
        jPanel2Layout.columnWidths = new int[] {240};
        jPanel2.setLayout(jPanel2Layout);

        jLabel1.setBackground(new java.awt.Color(230, 230, 250));
        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Graf Oluştur");
        jLabel1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                jLabel1MouseDragged(evt);
            }
        });
        jLabel1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel1MouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jLabel1MouseEntered(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(51, 97, 55, 112);
        jPanel2.add(jLabel1, gridBagConstraints);

        jPanel1.add(jPanel2);

        jPanel3.setBackground(new java.awt.Color(216, 191, 216));

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel2.setText("Musluk / Düğüm Sayısını Giriniz :");

        jScrollPane1.setViewportView(nodeCount);

        jButton1.setText("Onayla");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel3.setText("Musluk Bağlantılarını Belirle ");

        NodeSelectComboBox.setFont(new java.awt.Font("Segoe UI", 0, 15)); // NOI18N
        NodeSelectComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Musluk Seçiniz"}));
        NodeSelectComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NodeSelectComboBoxActionPerformed(evt);
            }
        });

        jCheckBox1.setText("Kaynak Musluk Mu?");

        jCheckBox2.setText("Son Musluk Mu ?");

        selected1.setFont(new java.awt.Font("Segoe UI Semibold", 0, 16)); // NOI18N
        selected1.setText("Seçilen musluktan ");

        jTextField1.setText("B - 5");
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        selected2.setFont(new java.awt.Font("Segoe UI Semibold", 0, 16)); // NOI18N
        selected2.setText("Seçilen musluktan ");

        jTextField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField2ActionPerformed(evt);
            }
        });

        selected3.setFont(new java.awt.Font("Segoe UI Semibold", 0, 16)); // NOI18N
        selected3.setText("Seçilen musluktan ");

        jTextField3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField3ActionPerformed(evt);
            }
        });

        selected4.setFont(new java.awt.Font("Segoe UI Semibold", 0, 16)); // NOI18N
        selected4.setText("Seçilen musluktan ");

        jTextField4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField4ActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel4.setText("Musluk Bağlantılarını onayla : ");

        nodeConnectionBtn.setText("Onayla");
        nodeConnectionBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                nodeConnectionBtnMouseClicked(evt);
            }
        });

        jButton3.setText("Musluk Log");
        jButton3.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton3MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(selected2)
                        .addGap(29, 29, 29)
                        .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3)
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addGap(13, 13, 13)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel4)
                                    .addComponent(jCheckBox1))))
                        .addGap(65, 65, 65)
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(NodeSelectComboBox, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jCheckBox2, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE)
                            .addComponent(nodeConnectionBtn)))
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel3Layout.createSequentialGroup()
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 106, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton1))
                        .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(selected1)
                        .addGap(29, 29, 29)
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(jPanel3Layout.createSequentialGroup()
                            .addComponent(selected4)
                            .addGap(29, 29, 29)
                            .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(jPanel3Layout.createSequentialGroup()
                            .addComponent(selected3)
                            .addGap(29, 29, 29)
                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(177, 177, 177))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton3)
                .addGap(40, 40, 40))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(59, 59, 59)
                .addComponent(jLabel2)
                .addGap(18, 18, 18)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1))
                .addGap(37, 37, 37)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(NodeSelectComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selected1)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selected2)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selected3)
                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selected4)
                    .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 112, Short.MAX_VALUE)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBox1)
                    .addComponent(jCheckBox2))
                .addGap(71, 71, 71)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(nodeConnectionBtn))
                .addGap(18, 18, 18)
                .addComponent(jButton3)
                .addGap(10, 10, 10))
        );

        jPanel1.add(jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 902, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>                        

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void jTextField3ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void jTextField4ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void NodeSelectComboBoxActionPerformed(java.awt.event.ActionEvent evt) {                                                   
        // TODO add your handling code here:
        
        String sItem = NodeSelectComboBox.getSelectedItem().toString();
        
        selected1.setText(sItem+" den");
        selected2.setText(sItem+" den");
        selected3.setText(sItem+" den");
        selected4.setText(sItem+" den");
        
    }                                                  

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
        
        String text = nodeCount.getText();
        nodeC = Integer.parseInt(text);
        items = new String[nodeC];
        
        char[] alphabet = new char[26];
        for(int i = 0; i < 26; i++){
            alphabet[i] = (char)(65 + i);
        }

        for (int i = 0; i < nodeC; i++) {
            items[i] = "Musluk "+ alphabet[i];
        }
        
        //build graph model
        graph = new int[nodeC][nodeC];
        for (int i = 0; i < nodeC; i++) {
            for (int j = 0; j < nodeC; j++) {
                graph[i][j] = 0;
            }            
        }
        
        final DefaultComboBoxModel model = new DefaultComboBoxModel(items);
        NodeSelectComboBox.setModel(model);
    }                                        

    private void jLabel1MouseClicked(java.awt.event.MouseEvent evt) {                                     
        // Graf oluştur butonu işlevi görecek
       
    }                                    

    private void jLabel1MouseEntered(java.awt.event.MouseEvent evt) {                                     
        // TODO add your handling code here:
       
    }                                    

    private void jLabel1MouseDragged(java.awt.event.MouseEvent evt) {                                     
        // TODO add your handling code here:
        
    }                                    

    private void jPanel2MouseEntered(java.awt.event.MouseEvent evt) {                                     
        // TODO add your handling code here:
         jPanel2.setBackground(new java.awt.Color(221,161,221));
    }                                    

    private void jPanel2MouseExited(java.awt.event.MouseEvent evt) {                                    
        // TODO add your handling code here:
        jPanel2.setBackground(new java.awt.Color(230, 230, 250));
    }                                   

    private void jButton3MouseClicked(java.awt.event.MouseEvent evt) {                                      
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(null, info, "Musluk Özellikleri: ", JOptionPane.INFORMATION_MESSAGE);
    }                                     

   
    
    private void nodeConnectionBtnMouseClicked(java.awt.event.MouseEvent evt) {                                               
        // TODO add your handling code here:
                
        boolean isSource = jCheckBox1.isSelected();
        System.out.println("isSource"+ isSource);
        String src = "";
        if (isSource){
            src = "--> Kaynak musluk";
            jCheckBox1.setVisible(false);
            jCheckBox1.setSelected(false);
        }
          
        boolean isSink = jCheckBox2.isSelected();
        String sink = "";
        if (isSink){
            sink = "--> Son musluk\n";
            jCheckBox2.setVisible(false);
            jCheckBox2.setSelected(false);
        }
            
        
        String sItem = NodeSelectComboBox.getSelectedItem().toString();
        
        infoBuilder.append(sItem +" ");
        infoBuilder.append(src + "\n");
        infoBuilder.append(sink + "\n");
        
        infoBuilder.append(jTextField1.getText().toString()+ "\n");
        infoBuilder.append(jTextField2.getText().toString()+ "\n");
        infoBuilder.append(jTextField3.getText().toString()+ "\n");
        infoBuilder.append(jTextField4.getText().toString()+ "*\n");
        
        info = infoBuilder.toString();
        
    }                                              

     // Driver program to test above functions
    public static int[][] makeGraph (String info)
    {
         System.out.println("infoooooooooooooooooo" +  info + "----------------------");
        int[][] temp;
        /*info = "Musluk A --> Kaynak musluk\n" +
            "B - 6\n" +
            "C - 6\n" +
            "*\n" +
            "Musluk B \n" +
            "D - 4\n" +
            "E - 2\n" +
            "*\n" +
            "Musluk C \n" +
            "B - 5\n" +
            "E - 9\n" +
            "*\n" +
            "Musluk D \n" +
            "F - 4\n" +
            "G - 7\n" +
            "*\n" +
            "Musluk E \n" +
            "D - 8\n" +
            "G - 7\n" +
            "*\n" +
            "Musluk F \n" +
            "H - 7\n" +
            "*\n" +
            "Musluk G \n" +
            "F - 11\n" +
            "H - 4\n" +
            "*\n" +
            "Musluk H \n" +
            "--> Son musluk\n" +
           "*\r\n" +
                "";
*/
      
        String nodes[] = info.split("\\*");
        String[][] lines = new String[nodes.length][];
        for(int i = 0; i< nodes.length; i++) {
            nodes[i] = nodes[i] .replaceAll("(?m)^[ \t]*\r?\n", "");
            lines[i] = nodes[i].split("\\r?\\n");
        }
        System.out.println("node.length : "+nodes.length + "lines[0].length :  "+ lines[0].length);
        for(int i = 0; i< nodes.length ; i++) {
            for(int j = 0; j< lines[i].length; j++) {
                System.out.println(lines[i][j]);
            }
        }

        temp = new int[nodes.length -1][nodes.length -1];
        // Fill each row with 0
        for(int i = 0; i< temp.length ; i++) {
            for(int j = 0; j< temp[i].length; j++) {
                temp[i][j] = 0;
            }

        }

        //kaynak m� diye kontrol et
        //de�ilse ba�lant�lar�n� al
        boolean isSrc = false;
        boolean isSnk = false;

        System.out.println("temp boyutu : "+ (nodes.length -1));
        int[] tempAry = new int[nodes.length -1];
        Arrays.fill(tempAry, new Integer(0));


        int[] srcAry = new int[nodes.length -1];
        Arrays.fill(srcAry, new Integer(0));

        for(int j = 0; j< srcAry.length; j++) {
            System.out.println(srcAry[j]);
        }

        char src = 'D';
        char toWhere;
        String str = "";

        for(int i = 0; i< nodes.length -2; i++) {
            //kaynak musluk durumu
            if (lines[i][0].contains("Kaynak")) {

                //find source index
                src = lines[i][0].charAt(7);
                int srcNmb = src -65;
                System.out.println("kaynak node : "+srcNmb);

                for(int j = 1; j< lines[i].length; j++) {

                    //Find where to connect
                    str = lines[i][j];
                    toWhere = str.charAt(0);
                    int chrNmb = toWhere -65;

                    //connection capacity
                    str = str.replaceAll("\\D+","");

                    System.out.println(chrNmb + "--" + str);

                    srcAry[chrNmb] = Integer.parseInt(str);
                }
                temp[0] = srcAry;
            }
            //Son musluk durumu
			/*else if (lines[i][1].contains("Son")) {

				//find source index
				src = lines[i][0].charAt(7);
				int snkNmb = src -65;
				System.out.println("Son node : "+snkNmb);

				int[] lst = new int[nodes.length -1];
				Arrays.fill(lst, new Integer(0));

				temp[temp.length -1] = lst;
			}*/
            else {
                //find source index
                src = lines[i][0].charAt(7);
                int srcNmb = src -65;
                Arrays.fill(tempAry, 0);
                System.out.println("kaynak node : "+srcNmb);
                for(int j = 1; j< lines[i].length; j++) {

                    //Find where to connect
                    str = lines[i][j];
                    toWhere = str.charAt(0);
                    int chrNmb = toWhere -65;

                    //connection capacity
                    str = str.replaceAll("\\D+","");

                    System.out.println(chrNmb + "--" + str);

                    if (!str.isEmpty()) {
                        tempAry[chrNmb] = Integer.parseInt(str);
                    }

                }
                System.out.println(i);
                for (int j = 0; j < tempAry.length; j++) {
                    System.out.print(tempAry[j] + "\t");
                    temp[i][j] = tempAry[j];
                }
                System.out.println();
                //temp[i] = tempAry;
            }


        }

        System.out.println("Son durum: \n -----------------------------------------------");
        for(int i = 0; i< temp.length ; i++) {
            for(int j = 0; j< temp[i].length; j++) {
                System.out.print(temp[i][j] + "\t");
            }
            System.out.println();
        }

    return temp;
    }

  
    
    private void jPanel2MouseClicked(java.awt.event.MouseEvent evt) {                                     
        // TODO add your handling code here:
        if(!(jCheckBox1.isVisible() && jCheckBox2.isVisible())){
            System.out.println("Graph oluşturuluyor");
            
            //send all datas to make graph
            info = info .replaceAll("(?m)^[ \t]*\r?\n", "");
            System.out.println(info);
            int[][] graph = makeGraph(info);
            
            Graf gii;
            gii = new Graf(graph.length, items, graph, info);
            dispose();
            
        }else {
            System.out.println("Kaynak veya Son musluk seçilmedi");
        }
        
        
        
    }                                    

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Requirements.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Requirements.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Requirements.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Requirements.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Requirements().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JComboBox<String> NodeSelectComboBox;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton3;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextField jTextField4;
    private javax.swing.JButton nodeConnectionBtn;
    private javax.swing.JTextPane nodeCount;
    private javax.swing.JLabel selected1;
    private javax.swing.JLabel selected2;
    private javax.swing.JLabel selected3;
    private javax.swing.JLabel selected4;
    // End of variables declaration                   
}


//MaxFlow.class
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maxflowgui;

/**
 *
 * @author Mahmut
 */

// Java program for implementation of Ford Fulkerson algorithm
import java.util.*;
import java.util.LinkedList;

public class MaxFlow{


	/* Returns true if there is a path from source 's' to sink 
	't' in residual graph. Also fills parent[] to store the 
	path */
	boolean bfs(int rGraph[][], int s, int t, int parent[]) 
	{ 
                int V = rGraph.length;
		// Create a visited array and mark all vertices as not 
		// visited 
		boolean visited[] = new boolean[V]; 
		for(int i=0; i<V; ++i) 
			visited[i]=false; 

		// Create a queue, enqueue source vertex and mark 
		// source vertex as visited 
		LinkedList<Integer> queue = new LinkedList<>(); 
		queue.add(s); 
		visited[s] = true; 
		parent[s]=-1; 

		// Standard BFS Loop 
		while (!queue.isEmpty()) 
		{ 
			int u = queue.poll(); 

			for (int v=0; v<V; v++) 
			{ 
				if (visited[v]==false && rGraph[u][v] > 0) 
				{ 
					queue.add(v); 
					parent[v] = u; 
					visited[v] = true; 
				} 
			} 
		} 

		// If we reached sink in BFS starting from source, then 
		// return true, else false 
		return (visited[t] == true); 
	} 
        StringBuilder sb = new StringBuilder();
	// Returns tne maximum flow from s to t in the given graph 
	int fordFulkerson(int graph[][], int s, int t, int V) 
	{ 
		int u, v; 

		// Create a residual graph and fill the residual graph 
		// with given capacities in the original graph as 
		// residual capacities in residual graph 

		// Residual graph where rGraph[i][j] indicates 
		// residual capacity of edge from i to j (if there 
		// is an edge. If rGraph[i][j] is 0, then there is 
		// not) 
		int rGraph[][] = new int[V][V]; 

		for (u = 0; u < V; u++) 
			for (v = 0; v < V; v++) 
				rGraph[u][v] = graph[u][v]; 

		// This array is filled by BFS and to store path 
		int parent[] = new int[V]; 

		int max_flow = 0; // There is no flow initially 
		// Augment the flow while tere is path from source 
		// to sink 
		while (bfs(rGraph, s, t, parent)) 
		{ 
			// Find minimum residual capacity of the edhes 
			// along the path filled by BFS. Or we can say 
			// find the maximum flow through the path found. 
			int path_flow = Integer.MAX_VALUE; 
			for (v=t; v!=s; v=parent[v]) 
			{ 
				u = parent[v]; 
				path_flow = Math.min(path_flow, rGraph[u][v]);
                                sb.append("Musluk"+(char)(65+v) +" --" +"-- Musluk"+ (char)(65+u)+" --- Kapasite: " +rGraph[u][v] +"\n");
                                System.out.println("Musluk"+(char)(65+v) +" --" +"-- Musluk"+ (char)(65+u)+" --- Kapasite: " +rGraph[u][v]);
                                        
			} 

			// update residual capacities of the edges and 
			// reverse edges along the path 
			for (v=t; v != s; v=parent[v]) 
			{ 
				u = parent[v]; 
				rGraph[u][v] -= path_flow; 
				rGraph[v][u] += path_flow; 
                                //System.out.println("rgragh uv: "+ rGraph[u][v]+ "   rgragh vu: "+ rGraph[v][u]+ "  u : "+u+"  -- path flow : "+ path_flow);
			} 

			// Add path flow to overall flow
                        sb.append("-Yol üzerindeki en küçük kapasite (BottleNeck) : " + path_flow + "\n");
                        System.out.println("-------------Yol üzerindeki en küçük kapasite (BottleNeck) : " + path_flow);
			max_flow += path_flow; 
		} 

		// Return the overall flow 
		return max_flow; 
	}
        public String getString(){
            return sb.toString();
        }

    //find graph from given string
    public static int[][] findGraph (String string)
    {
        int[][] temp;
        String info = string;

        String nodes[] = info.split("\\*");
        String[][] lines = new String[nodes.length][];
        for(int i = 0; i< nodes.length; i++) {
            nodes[i] = nodes[i] .replaceAll("(?m)^[ \t]*\r?\n", "");
            lines[i] = nodes[i].split("\\n");
        }

        for(int i = 0; i< nodes.length ; i++) {
            for(int j = 0; j< lines[i].length; j++) {
                System.out.print(lines[i][j]);
            }
        }

        temp = new int[nodes.length -1][nodes.length -1];
            // Fill each row with 0
            for (int[] temp1 : temp) {
                for (int j = 0; j < temp1.length; j++) {
                    temp1[j] = 0;
                }
            }

        //kaynak m� diye kontrol et
        //de�ilse ba�lant�lar�n� al
        boolean isSrc = false;
        boolean isSnk = false;

        System.out.println("temp boyutu : "+ (nodes.length -1));
        int[] tempAry = new int[nodes.length -1];
        Arrays.fill(tempAry, new Integer(0));


        int[] srcAry = new int[nodes.length -1];
        Arrays.fill(srcAry, new Integer(0));

        for(int j = 0; j< srcAry.length; j++) {
            System.out.println(srcAry[j]);
        }

        char src = 'D';
        char toWhere;
        String str = "";

        for(int i = 0; i< nodes.length -2; i++) {
            //kaynak musluk durumu
            if (lines[i][0].contains("Kaynak")) {

                //find source index
                src = lines[i][0].charAt(7);
                int srcNmb = src -65;
                System.out.println("kaynak node : "+srcNmb);

                for(int j = 1; j< lines[i].length; j++) {

                    //Find where to connect
                    str = lines[i][j];
                    toWhere = str.charAt(0);
                    int chrNmb = toWhere -65;

                    //connection capacity
                    str = str.replaceAll("\\D+","");

                    System.out.println(chrNmb + "--" + str);

                    srcAry[chrNmb] = Integer.parseInt(str);
                }
                temp[0] = srcAry;
            }
            //Son musluk durumu
			/*else if (lines[i][1].contains("Son")) {

				//find source index
				src = lines[i][0].charAt(7);
				int snkNmb = src -65;
				System.out.println("Son node : "+snkNmb);

				int[] lst = new int[nodes.length -1];
				Arrays.fill(lst, new Integer(0));

				temp[temp.length -1] = lst;
			}*/
            else {
                //find source index
                src = lines[i][0].charAt(7);
                int srcNmb = src -65;
                Arrays.fill(tempAry, 0);
                System.out.println("kaynak node : "+srcNmb);
                for(int j = 1; j< lines[i].length; j++) {

                    //Find where to connect
                    str = lines[i][j];
                    toWhere = str.charAt(0);
                    int chrNmb = toWhere -65;

                    //connection capacity
                    str = str.replaceAll("\\D+","");

                    System.out.println(chrNmb + "--" + str);

                    if (!str.isEmpty()) {
                        tempAry[chrNmb] = Integer.parseInt(str);
                    }

                }
                System.out.println(i);
                for (int j = 0; j < tempAry.length; j++) {
                    System.out.print(tempAry[j] + "\t");
                    temp[i][j] = tempAry[j];
                }
                System.out.println();
                //temp[i] = tempAry;
            }


        }

        System.out.println("Son durum: \n -----------------------------------------------");
        for(int i = 0; i< temp.length ; i++) {
            for(int j = 0; j< temp[i].length; j++) {
                System.out.print(temp[i][j] + "\t");
            }
            System.out.println();
        }

    return temp;
    }
}
//MinCut.class
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maxflowgui;

/**
 *
 * @author siebe
 */
import java.util.LinkedList; 
import java.util.Queue; 

public class MinCut {
    

// Java program for finding min-cut in the given graph 
		
	// Returns true if there is a path 
	// from source 's' to sink 't' in residual 
	// graph. Also fills parent[] to store the path 
	private static boolean bfs(int[][] rGraph, int s, int t, int[] parent) { 
		
		// Create a visited array and mark 
		// all vertices as not visited	 
		boolean[] visited = new boolean[rGraph.length]; 
		
		// Create a queue, enqueue source vertex 
		// and mark source vertex as visited	 
		Queue<Integer> q = new LinkedList<Integer>(); 
		q.add(s); 
		visited[s] = true; 
		parent[s] = -1; 
		
		// Standard BFS Loop	 
		while (!q.isEmpty()) { 
			int v = q.poll(); 
			for (int i = 0; i < rGraph.length; i++) { 
				if (rGraph[v][i] > 0 && !visited[i]) { 
					q.offer(i); 
					visited[i] = true; 
					parent[i] = v; 
				} 
			} 
		} 
		
		// If we reached sink in BFS starting 
		// from source, then return true, else false	 
		return (visited[t] == true); 
	} 
	
	// A DFS based function to find all reachable 
	// vertices from s. The function marks visited[i] 
	// as true if i is reachable from s. The initial 
	// values in visited[] must be false. We can also 
	// use BFS to find reachable vertices 
	private static void dfs(int[][] rGraph, int s, boolean[] visited) { 
		visited[s] = true; 
		for (int i = 0; i < rGraph.length; i++) { 
				if (rGraph[s][i] > 0 && !visited[i]) { 
					dfs(rGraph, i, visited); 
				} 
		} 
	} 

	// Prints the minimum s-t cut 
	public static String minCut(int[][] graph, int s, int t) { 
		int u,v; 
		
		// Create a residual graph and fill the residual 
		// graph with given capacities in the original 
		// graph as residual capacities in residual graph 
		// rGraph[i][j] indicates residual capacity of edge i-j 
		int[][] rGraph = new int[graph.length][graph.length]; 
		for (int i = 0; i < graph.length; i++) { 
			for (int j = 0; j < graph.length; j++) { 
				rGraph[i][j] = graph[i][j]; 
			} 
		} 

		// This array is filled by BFS and to store path 
		int[] parent = new int[graph.length]; 
		
		// Augment the flow while tere is path from source to sink	 
		while (bfs(rGraph, s, t, parent)) { 
			
			// Find minimum residual capacity of the edhes 
			// along the path filled by BFS. Or we can say 
			// find the maximum flow through the path found. 
			int pathFlow = Integer.MAX_VALUE;		 
			for (v = t; v != s; v = parent[v]) { 
				u = parent[v]; 
				pathFlow = Math.min(pathFlow, rGraph[u][v]); 
			} 
			
			// update residual capacities of the edges and 
			// reverse edges along the path 
			for (v = t; v != s; v = parent[v]) { 
				u = parent[v]; 
				rGraph[u][v] = rGraph[u][v] - pathFlow; 
				rGraph[v][u] = rGraph[v][u] + pathFlow; 
			} 
		} 
		
		// Flow is maximum now, find vertices reachable from s	 
		boolean[] isVisited = new boolean[graph.length];	 
		dfs(rGraph, s, isVisited); 
		
                
                StringBuilder strB = new StringBuilder();
		// Print all edges that are from a reachable vertex to 
		// non-reachable vertex in the original graph	 
		for (int i = 0; i < graph.length; i++) { 
			for (int j = 0; j < graph.length; j++) { 
				if (graph[i][j] > 0 && isVisited[i] && !isVisited[j]) { 
                                        strB.append("Musluk" +(char)(65 + i) +
                                                " - " +"Musluk" + (char)(65 + j) + "\n");
					//System.out.println(i + " - " + j); 
				} 
			} 
		}
                return strB.toString();
	}  
} 



